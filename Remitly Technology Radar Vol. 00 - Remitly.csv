name,ring,quadrant,isNew,description,TEAMS
,Adopt,Techniques,,,
,Assess,Platforms,,,
,Trial,Tools,,,
,Hold,languages-and-frameworks,,,
Applying product management to internal platforms,Assess,Techniques,FALSE,"<p>More and more companies are building internal platforms to roll out new digital solutions quickly and efficiently. Companies that succeed with this strategy are <strong>applying product management to internal platforms</strong>. This means establishing empathy with internal consumers (the development teams) and collaborating with them on the design. Platform product managers create roadmaps and ensure the platform delivers value to the business and enhances the developer experience. Unfortunately, we're also seeing less successful approaches, where teams create a platform in the void, based on unverified assumptions and without internal customers. These platforms, often despite aggressive internal tactics, end up being underutilized and a drain on the organization's delivery capability. As usual, good product management is all about building products that consumers love.</p><p>teams goes here</p>",
Infrastructure as code,Assess,Techniques,FALSE,"<p>Although <strong>infrastructure as code</strong> is a relatively old technique (we’ve featured it in the Radar in 2011), it has become vitally important in the modern cloud era where the act of setting up infrastructure has become the passing of configuration instructions to a cloud platform. When we say ""as code"" we mean that all the good practices we've learned in the software world should be applied to infrastructure. Using source control, adhering to the <a href=""https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"">DRY principle</a>, modularization, maintainability, and using automated testing and deployment are all critical practices. Those of us with a deep software and infrastructure background need to empathize with and support colleagues who do not. Saying ""treat infrastructure like code"" isn't enough; we need to ensure the hard-won learnings from the software world are also applied consistently throughout the infrastructure realm.</p>",
Micro frontends,Assess,Techniques,FALSE,"<p>We've seen significant benefits from introducing <a href=""https://martinfowler.com/articles/microservices.html"">microservices</a>, which have allowed teams to scale the delivery of independently deployed and maintained services. Unfortunately, we've also seen many teams create a front-end monolith — a large, entangled browser application that sits on top of the back-end services — largely neutralizing the benefits of microservices. <strong>Micro frontends</strong> have continued to gain in popularity since they were first introduced. We've seen many teams adopt some form of this architecture as a way to manage the complexity of multiple developers and teams contributing to the same user experience. In June of last year, one of the originators of this technique published an <a href=""https://martinfowler.com/articles/micro-frontends.html"">introductory article</a> that serves as a reference for micro frontends. It shows how this style can be implemented using various web programming mechanisms and builds out an example application using <a href=""/radar/languages-and-frameworks/react-js"">React.js</a>. We're confident this style will grow in popularity as larger organizations try to decompose UI development across multiple teams.</p><p>IPROD(assess)</p>",
Pipelines as code,Adopt,Techniques,FALSE,"<p>The <strong>pipelines as code</strong> technique emphasizes that the configuration of delivery pipelines that build, test and deploy our applications or infrastructure should be treated as code; they should be placed under source control and modularized in reusable components with automated testing and deployment. As organizations move to decentralized autonomous teams building <a href=""https://martinfowler.com/articles/microservices.html"">microservices</a> or <a href=""/radar/techniques/micro-frontends"">micro frontends</a>, the need for engineering practices in managing pipelines as code increases to keep building and deploying software consistent within the organization. This need has given rise to delivery pipeline templates and tooling that enable a standardized way to build and deploy services and applications. Such tools use the <em>declarative delivery pipelines</em> of applications, adopting a pipeline blueprint to execute the underlying tasks for various stages of a delivery lifecycle such as build, test and deployment; and they abstract away implementation details. The ability to build, test and deploy pipelines as code should be one of the evaluation criteria for choosing a CI/CD tool.</p>",
Pragmatic remote pairing,Assess,Techniques,TRUE,"<p>We firmly believe that <a href=""https://martinfowler.com/articles/on-pair-programming.html"">pair programming</a> improves the quality of code, spreads knowledge throughout a team and allows overall faster delivery of software. In a post COVID-19 world, however, many software teams will be distributed or fully remote, and in this situation we recommend <strong>pragmatic remote pairing</strong>: adjusting pairing practices to what's possible given the tools at hand. Consider tools such as <a href=""/radar/tools/visual-studio-live-share"">Visual Studio Live Share</a> for efficient, low-latency collaboration. Only resort to pixel-sharing if both participants reside in relative geographic proximity and have high-bandwidth internet connections. Pair developers who are in similar time zones rather than expecting pairing to work between participants regardless of their location. If pairing isn't working for logistical reasons, fall back to practices such as individual programming augmented via code reviews, pull-request collaboration (but beware <a href=""/radar/techniques/long-lived-branches-with-gitflow"">long-lived branches with Gitflow</a>) or shorter pairing sessions for critical parts of the code. We've engaged in remote pairing for years, and we've found it to be effective if done with a dose of pragmatism.</p>",
Simplest possible feature toggle,Trial,Techniques,TRUE,"<p>Unfortunately, <a href=""https://martinfowler.com/articles/feature-toggles.html"">feature toggles</a> are less common than we'd like, and quite often we see people mixing up its types and use cases. It's quite common to come across teams that use heavyweight platforms such as <a href=""https://launchdarkly.com/"">LaunchDarkly</a> to implement feature toggles, including release toggles, to benefit from <a href=""https://martinfowler.com/articles/continuousIntegration.html"">Continuous Integration</a>, when all you need are if/else conditionals. Therefore, unless you need A/B testing or <a href=""https://martinfowler.com/bliki/CanaryRelease.html"">canary release</a> or hand over feature release responsibility to business folks, we encourage you to use the <strong>simplest possible feature toggle</strong> instead of unnecessarily complex feature toggle frameworks.</p>",
Continuous delivery for machine learning (CD4ML),Trial,Techniques,FALSE,"<p>Applying machine learning to make the business applications and services intelligent is more than just training models and serving them. It requires implementing end-to-end and continuously repeatable cycles of training, testing, deploying, monitoring and operating the models. <strong><a href=""https://martinfowler.com/articles/cd4ml.html"">Continuous delivery for machine learning (CD4ML)</a></strong> is a technique that enables reliable end-to-end cycles of development, deploying and monitoring machine learning models. The underpinning technology stack to enable CD4ML includes tooling for accessing and discovering data, version control of artefacts (such as data, model and code), continuous delivery pipelines, automated environment provisioning for various deployments and experiments, model performance assessment and tracking, and model operational observability. Companies can choose their own tool set depending on their existing tech stack. CD4ML emphasizes automation and removing manual handoffs. CD4ML is our de facto approach for developing ML models.</p>",
Micro frontends for mobile,Assess,Techniques,TRUE,"<p>Since introducing it in the Radar in 2016, we've seen widespread adoption of <a href=""/radar/techniques/micro-frontends"">micro frontends</a> for web UIs. Recently, however, we've seen projects extend this architectural style to include <strong>micro frontends for mobile</strong> applications as well. When the application becomes sufficiently large and complex, it becomes necessary to distribute the development over multiple teams. This presents the challenge of maintaining team autonomy while integrating their work into a single app. Although we've seen teams writing their own frameworks to enable this development style, existing modularization frameworks such as <a href=""/radar/languages-and-frameworks/atlas-and-beehive"">Atlas and Beehive</a> can also simplify the problem of integrating multiteam app development.</p><p>IPROD (assess)</p>",
Platform engineering product teams,Trial,Techniques,FALSE,"<p>The adoption of cloud and DevOps — while increasing the productivity of teams who can now move more quickly with reduced dependency on centralized operations teams and infrastructure — also has constrained teams that lack the skills to self-manage a full application and operations stack. Some organizations have tackled this challenge by creating <strong>platform engineering product teams</strong>. These teams maintain an internal platform that enables delivery teams to deploy and operate systems with reduced lead time and stack complexity. The emphasis here is on API-driven self-service and supporting tools, with delivery teams still responsible for supporting what they deploy onto the platform. Organizations that consider establishing such a platform team should be very cautious not to accidentally create a <a href=""/radar/techniques/separate-devops-team"">separate DevOps team</a>, nor should they simply relabel their <a href=""/radar/platforms/superficial-private-cloud"">existing hosting and operations structure</a> as a platform. If you're wondering how to best set up platform teams, we've been using the concepts from <a href=""https://teamtopologies.com/"">Team Topologies</a> to split platform teams in our projects into enablement teams, core ""platform within a platform"" teams and stream-focused teams.</p>",
Security policy as code,Trial,Techniques,FALSE,"<p>Security policies are rules and procedures that protect our systems from threats and disruption. For example, access control policies define and enforce who can access which services and resources under what circumstances; or network security policies can dynamically limit the traffic rate to a particular service. The complexity of the technology landscape today demands treating <strong>security policy as code</strong>: define and keep policies under version control, automatically validate them, automatically deploy them and monitor their performance. Tools such as <a href=""/radar/tools/open-policy-agent-opa"">Open Policy Agent</a> or platforms such as <a href=""/radar/platforms/istio"">Istio</a> provide flexible policy definition and enforcement mechanisms that support the practice of security policy as code.</p>",
"Use ""remote native"" processes and approaches",Trial,Techniques,TRUE,"<p><a href=""https://www.martinfowler.com/articles/remote-or-co-located.html"">Distributed teams come in many shapes and setups</a>; delivery teams in a 100% single-site co-located setup, however, have become the exception for us. Most of our teams are either multisite teams or have at least some team members working off-site. Therefore, <strong>using ""remote native"" processes and approaches</strong> by default can help significantly with the overall team flow and effectiveness. This starts with making sure that everybody has access to the necessary remote systems. Moreover, using tools such as <a href=""/radar/tools/visual-studio-live-share"">Visual Studio Live Share</a>, <a href=""/radar/tools/mural"">MURAL</a> or <a href=""https://gsuite.google.com/products/jamboard/"">Jamboard</a> turn online workshops and remote pairing into routines instead of ineffective exceptions. But ""remote native"" goes beyond a lift-and-shift of co-location practices to the digital world: Embracing more asynchronous communication, even more discipline around decision documentation, and ""everybody always remote"" meetings are other approaches our teams practice by default to optimize for location fluidity.</p>",
Log aggregation for business analytics,Hold,Techniques,TRUE,"<p>Several years ago, a new generation of log aggregation platforms emerged that were capable of storing and searching over vast amounts of log data to uncover trends and insights in operational data. <a href=""/radar/tools/splunk"">Splunk</a> was the most prominent but by no means the only example of these tools. Because these platforms provide broad operational and security visibility across the entire estate of applications, administrators and developers have grown increasingly dependent on them. This enthusiasm spread as stakeholders discovered that they could use <strong>log aggregation for business analytics</strong>. However, business needs can quickly outstrip the flexibility and usability of these tools. Logs intended for technical observability are often inadequate to infer deep customer understanding. We prefer either to use tools and metrics designed for customer analytics or to take a more event-driven approach to observability where both business and operational events are collected and stored in a way they can be replayed and processed by more purpose-built tools.</p>",
Long-lived branches with Gitflow,Hold,Techniques,FALSE,"<p>Five years ago we highlighted the problems with <strong>long-lived branches with Gitflow</strong>. Essentially, long-lived branches are the opposite of continuously integrating all changes to the source code, and in our experience continuous integration is the better approach for most kinds of software development. Later we extended our caution to <a href=""/radar/techniques/gitflow"">Gitflow</a> itself, because we saw teams using it almost exclusively with long-lived branches. Today, we still see teams in settings where continuous delivery of web-based systems is the stated goal being drawn to long-lived branches. So we were delighted that the author of Gitflow has now added a note to his <a href=""https://nvie.com/posts/a-successful-git-branching-model/"">original article</a>, explaining that Gitflow was not intended for such use cases.</p>",
Istio,Adopt,Platforms,FALSE,"<p>If you're building and operating a scaled <a href=""https://martinfowler.com/articles/microservices.html"">microservices</a> architecture and have embraced <a href=""/radar/platforms/kubernetes"">Kubernetes</a>, adopting <a href=""/radar/techniques/service-mesh"">service mesh</a> to manage all cross-cutting aspects of running the architecture is a default position. Among various implementations of service mesh, <strong><a href=""https://istio.io"">Istio</a></strong> has gained majority adoption. It has a rich feature set, including service discovery, traffic management, service-to-service and origin-to-service security, observability (including telemetry and distributed tracing), rolling releases and resiliency. Its user experience has been improved in its latest releases, because of its ease of installation and control panel architecture. Istio has lowered the bar for implementing large-scale microservices with operational quality for many of our clients, while admitting that operating your own Istio and Kubernetes instances requires adequate knowledge and internal resources which is not for the fainthearted.</p><p>Infra (adopt></p>",
Node overload,Hold,Platforms,TRUE,"<p>Technologies, especially wildly popular ones, have a tendency to be overused. What we're seeing at the moment is <strong>Node overload</strong>, a tendency to use Node.js indiscriminately or for the wrong reasons. Among these, two stand out in our opinion. Firstly, we frequently hear that Node should be used so that all programming can be done in one programming language. Our view remains that <a href=""/radar/techniques/polyglot-programming"">polyglot programming</a> is a better approach, and this still goes <a href=""/radar/languages-and-frameworks/javascript-as-a-first-class-language"">both ways</a>. Secondly, we often hear teams cite performance as a reason to choose Node.js. Although there are myriads of more or less sensible benchmarks, this perception is rooted in history. When Node.js became popular, it was the first major framework to embrace a nonblocking programming model which made it very efficient for IO-heavy tasks. (We mentioned this in our write-up of Node.js in 2012.) Due to its single-threaded nature, Node.js was never a good choice for compute-heavy workloads, though, and now that capable nonblocking frameworks also exist on other platforms — some with elegant, modern APIs — performance is no longer a reason to choose Node.js.</p>",
AWS,Adopt,Platforms,TRUE,,
Cypress E2E,Trial,Tools,FALSE,"<p><strong><a href=""http://www.cypress.io/"">Cypress</a></strong> is still a favorite among our teams where developers manage end-to-end tests themselves, as part of a healthy <a href=""https://martinfowler.com/articles/practical-test-pyramid.html#End-to-endTests"">test pyramid</a>, of course. We decided to call it out again in this Radar because recent versions of Cypress have added <a href=""https://cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/"">support for Firefox</a>, and we strongly suggest testing on multiple browsers. The dominance of Chrome and Chromium-based browsers has led to a worrying trend of teams seemingly only testing with Chrome which can lead to <a href=""https://twitter.com/mike_conley/status/1245797292453609478"">nasty surprises</a>.</p>",
Figma,Adopt,Tools,FALSE,"<p><strong><a href=""https://www.figma.com/"">Figma</a></strong> has demonstrated to be the go-to tool for collaborative design, not only for designers but for multidisciplinary teams too; it allows developers and other roles to view and comment on designs through the browser without the desktop version. Compared to its competitors (e.g., Invision or Sketch) which have you use more than one tool for versioning, collaborating and design sharing, Figma puts together all of these features in one tool that makes it easier for our teams to discover new ideas together. Our teams find Figma very useful, especially in remote and distributed design work enablement and facilitation. In addition to its real-time design and collaboration capabilities, Figma also offers an API that helps to improve the <a href=""/radar/techniques/designops"">DesignOps</a> process.</p>",
Jaeger,Adopt,Tools,FALSE,"<p><strong><a href=""https://github.com/jaegertracing/jaeger"">Jaeger</a></strong> is an open source distributed tracing system. Similar to <a href=""/radar/tools/zipkin"">Zipkin</a>, it's been inspired by the Google <a href=""https://ai.google/research/pubs/pub36356"">Dapper</a> paper and complies with <a href=""/radar/platforms/opentelemetry"">OpenTelemetry</a>. We've used Jaeger successfully with <a href=""/radar/platforms/istio"">Istio</a> and <a href=""https://www.envoyproxy.io/"">Envoy</a> on Kubernetes and like its <a href=""https://github.com/jaegertracing/jaeger-ui"">UI</a>. Jaeger exposes tracing metrics in the <a href=""/radar/tools/prometheus"">Prometheus</a> format so they can be made available to other tools. However, a new generation of tools such as <a href=""/radar/tools/honeycomb"">Honeycomb</a> integrates traces and metrics into a single observability stream for simpler aggregate analysis. Jaeger joined <a href=""https://www.cncf.io/blog/2017/09/13/cncf-hosts-jaeger/"">CNCF</a> in 2017 and has recently been elevated to CNCF's highest level of maturity, indicating its widespread deployment into production systems.</p>",
MURAL,Assess,Tools,TRUE,"<p><strong><a href=""https://www.mural.co/"">MURAL</a></strong> describes itself as a ""digital workspace for visual collaboration"" and allows teams to interact with a shared workspace based on a whiteboard/sticky notes metaphor. Its features include voting, commenting, notes and ""follow the presenter."" We particularly like the template feature that allows a facilitator to design and then reuse guided sessions with a team. Each of the major collaboration suites have a tool in this space (for example, <a href=""https://jamboard.google.com/"">Google Jamboard</a> and <a href=""https://www.microsoft.com/en-ca/microsoft-365/microsoft-whiteboard/digital-whiteboard-app"">Microsoft Whiteboard</a>) and these are worth investigating, but we've found MURAL to be slick, effective and flexible.</p>",
Visual regression testing tools,Trial,Tools,FALSE,"<p>Since we first mentioned <strong>visual regression testing tools</strong> in 2014, the use of the technique has spread and the tools landscape has evolved. <a href=""/radar/tools/backstopjs"">BackstopJS</a> remains an excellent choice with new features being added regularly, including support for running inside Docker containers. <a href=""/radar/tools/loki"">Loki</a> was featured in our previous Radar. <a href=""https://applitools.com/"">Applitools</a>, <a href=""https://crossbrowsertesting.com/"">CrossBrowserTesting</a> and <a href=""https://percy.io/"">Percy</a> are SaaS solutions. Another notable mention is <a href=""https://github.com/rsmbl"">Resemble.js</a>, an image diffing library. Although most teams use it indirectly as part of BackstopJS, some of our teams have been using it to analyze and compare images of web pages directly. In general, our experience shows that visual regression tools are less useful in the early stages when the interface goes through significant changes, but they certainly prove their worth as the product matures and the interface stabilizes.</p>",
Unleash,Adopt,Tools,TRUE,,
Go modules,Adopt,Tools,TRUE,,
DynamoDB,Adopt,Tools,TRUE,,
Kubernetes,Adopt,Tools,TRUE,,
React Hooks,Adopt,languages-and-frameworks,FALSE,"<p><strong><a href=""https://reactjs.org/docs/hooks-intro.html"">React Hooks</a></strong> have introduced a new approach to managing stateful logic; given React components have always been closer to functions than classes, Hooks have embraced this and brought state to the functions, instead of taking function as methods to the state with classes. Based on our experience, Hooks improve reuse of functionality among components and code readability. Given Hooks’ testability improvements, using <a href=""https://reactjs.org/docs/test-renderer.html"">React Test Renderer</a> and <a href=""/radar/languages-and-frameworks/react-testing-library"">React Testing Library</a>, and their growing community support, we consider them our approach of choice.</p><p>IPROD (adopt), APPX (adopt)</p>",
React Testing Library,Adopt,languages-and-frameworks,FALSE,"<p>The JavaScript world moves pretty fast, and as we gain more experience using a framework our recommendations change. The <strong><a href=""https://testing-library.com/"">React Testing Library</a></strong> is a good example of a framework that with deeper usage has eclipsed the alternatives to become the sensible default when testing React-based frontends. Our teams like the fact that tests written with this framework are less brittle than with alternative frameworks such as <a href=""/radar/languages-and-frameworks/enzyme"">Enzyme</a>, because you're encouraged to test component relationships individually as opposed to testing all implementation details. This mindset is brought by <a href=""https://testing-library.com/"">Testing Library</a> which React Testing Library is part of and which provides a whole family of libraries for <a href=""/radar/languages-and-frameworks/angular"">Angular</a> and <a href=""/radar/languages-and-frameworks/vue-js"">Vue.js</a>, for example.</p>",
CSS-in-JS,Adopt,languages-and-frameworks,FALSE,"<p>Since we first mentioned <strong>CSS-in-JS</strong> as an emerging technique in 2017, it has become much more popular, a trend we also see in our work. With some solid production experience under our belts, we can now recommend CSS-in-JS as a technique to trial. A good starting point is the <a href=""/radar/languages-and-frameworks/styled-components"">styled components</a> framework, which we mentioned in our previous Radar. Next to all the positives, though, there usually is a downside when using CSS-in-JS: the calculation of styles at runtime can cause a <a href=""https://calendar.perfplanet.com/2019/the-unseen-performance-costs-of-css-in-js-in-react-apps/"">noticeable lag for end users</a>. With <a href=""https://linaria.now.sh/"">Linaria</a> we're now seeing a new class of frameworks that were created with this issue in mind. Linaria employs a number of techniques to shift most of the performance overhead to build time. Alas, this does come with its own set of trade-offs, most notably a lack of dynamic style support in IE11.</p><p>APPX</p>",
Enzyme,Adopt,languages-and-frameworks,FALSE,"<p>We don't always move deprecated tools to Hold in the Radar, but our teams feel strongly that <strong><a href=""http://airbnb.io/enzyme/"">Enzyme</a></strong> has been replaced for unit testing <a href=""/radar/languages-and-frameworks/react-js"">React</a> UI components by <a href=""https://testing-library.com/docs/intro"">React Testing Library</a>. Teams using Enzyme have found that its focus on testing component internals leads to brittle, unmaintainable tests.</p><p>IPROD,APPX</p>",
React Native Web,Assess,languages-and-frameworks,TRUE,,
Java,Adopt,languages-and-frameworks,TRUE,<p>PAX</p>,
React,Adopt,languages-and-frameworks,FALSE,,
TypeScript,Adopt,languages-and-frameworks,FALSE,,
Kotlin,Adopt,languages-and-frameworks,FALSE,,
Go,Adopt,languages-and-frameworks,FALSE,,
Koa,Adopt,languages-and-frameworks,FALSE,,
Express,Adopt,languages-and-frameworks,FALSE,,
PHP,Hold,languages-and-frameworks,TRUE,,